#!/usr/bin/bc

# functions for operations on an elliptic curve

define slope_api(px, py, qx, qy, p){

    auto num, den;

    if (qy - py != 0){

        num = mod((qy - py),p);
        den = invmod((qx - px),p);

    } else {

	    num = mod((3 * px^2 + curve_a),p);
	    den = invmod((2 * py),p);
    }

    return (mod((num * den),p));
}

define slope(p, q){

    auto parr[], qarr[];

    uncompresspoint_api(p, parr[]);
    uncompresspoint_api(q, qarr[]);
    return slope_api(parr[0], parr[1], qarr[0], qarr[1], curve_p);
}

define void ecadd_api(px, py, qx, qy, p, *ret[]){

    auto slp;

    if (!ispoint_api(px, py, p) || !ispoint_api(qx, qy, p)){

        if (px == 0 && py == 0){

            ret[0] = qx;
            ret[1] = qy;
            return;
        }

        if (qx == 0 && qy == 0){

            ret[0] = px;
            ret[1] = py;
            return;
        }

        print "\n ### Not a point\n";
        ret[0] = 0;
        ret[1] = 0;
        return;
    }

    if (py != mod(-qy, p)){

        slp = slope_api(px, py, qx, qy, p);

        ret[0] = mod((slp^2 - px - qx),p);
        ret[1] = mod((slp*(px - rx) - py),p);
    }
}

define void ecadd(p, q){

    auto pret[], qret[], ret[];
    uncompresspoint_api(p, pret[]);
    uncompresspoint_api(q, qret[]);
    ecadd_api(pret[0], pret[1], qret[0], qret[1], curve_p, ret[]);
    compresspoint(ret[0], ret[1]);
}

define void ecmul_api(d, gx, gy, n, p, *ret[]){

    auto i, darr[], parr[];

    num2bitarr(d, darr[]);
    parr[0] = gx;
    parr[1] = gy;
    ret[0] = 0;
    ret[1] = 0;

    for (i=0; i < darr[0]; i++){

	    if (darr[i] == 1){
 
	        ecadd_api(parr[0], parr[1], ret[0], ret[1], curve_p, ret[]);
        }
        ecadd_api(parr[0], parr[1], parr[0], parr[1], curve_p, parr[]);
    }
}

define void ecmul(d){

    auto ret[];

    ecmul_api(d, curve_gx, curve_gy, curve_n, curve_p, ret[]);
    compresspoint(ret[0], ret[1]);
}
