#!/usr/bin/bc

# functions for operations on an elliptic curve

define slope_api(px, py, qx, qy, p){

    auto num, den;

    if (qy - py != 0){

        num = mod((qy - py),p);
        den = invmod((qx - px),p);

    } else {

	    num = mod((3 * px^2 + curve_a),p);
	    den = invmod((2 * py),p);
    }

    return (mod((num * den),p));
}

define slope(p, q){

    auto parr[], qarr[];

    uncompresspoint_api(p, parr[]);
    uncompresspoint_api(q, qarr[]);
    return slope_api(parr[0], parr[1], qarr[0], qarr[1], curve_p);
}

define void ecadd_api(px, py, qx, qy, p, *ret[]){

    auto slp;

    if ( !ispoint(px, py) || !ispoint(qx, qy)){

        if (px == 0 && py == 0){

            ret[0] = qx;
            ret[1] = qy;
            return;
        }

        if (qx == 0 && qy == 0){

            ret[0] = px;
            ret[1] = py;
            return;
        }

        print "\n ### Not a point\n";
        ret[0] = 0;
        ret[1] = 0;
        return;
    }

    if (py != mod(-qy, p)){

        slp = slope_api(px, py, qx, qy, p);

        ret[0] = mod((slp^2 - px - qx),p);
        ret[1] = mod((slp*(px - ret[0]) - py),p);
    }
}

define void ecadd(p, q){

    auto pret[], qret[], ret[];
    uncompresspoint_api(p, pret[]);
    uncompresspoint_api(q, qret[]);
    ecadd_api(pret[0], pret[1], qret[0], qret[1], curve_p, ret[]);
    compresspoint(ret[0], ret[1]);
}

define void ecmul_api(d, gx, gy, n, p, *ret[]){

    auto i, parr[];

    parr[0] = gx;
    parr[1] = gy;
    ret[0] = 0;
    ret[1] = 0;

    if (d < 0){
        d = mod(d, n);
    }
    if (d > n/2){
        d = mod(-d, n);
        parr[1] = mod(-gy, p);
    }

    while (d > 0){

        if (d % 2){
 
	        ecadd_api(parr[0], parr[1], ret[0], ret[1], curve_p, ret[]);
        }
        ecadd_api(parr[0], parr[1], parr[0], parr[1], curve_p, parr[]);
        d /= 2;
    }
}

define void ecmul(d){

    auto ret[];

    ecmul_api(d, curve_gx, curve_gy, curve_n, curve_p, ret[]);
    compresspoint(ret[0], ret[1]);
}

define void ecmul_fast_api(d, qx, qy, n, p, *ret[]){

    auto lambda_q[], k[], p1[], p2[];

    if (d < 0){
        d = mod(d, n);
    }
    if (d > n/2){
        d = mod(-d, n);
        qy = mod(-qy, p);
    }
    get_lambda_point_api(endomorphism_beta, qx, qy, p, lambda_q[]);

    balanced_length_api(d, endomorphism_a1, endomorphism_b1, endomorphism_a2, endomorphism_b2, n, k[]);
    ecmul_api(k[0] ,qx, qy, n, p, p1[]);
    ecmul_api(-k[1], lambda_q[0], -lambda_q[1], n, p, p2[]);
    ecadd_api(p1[0], p1[1], p2[0], p2[1], p, ret[]);
}

define void fastecmul(d){

    auto ret[];
    ecmul_fast_api(d, curve_gx, curve_gy, curve_n, curve_p, ret[]);
    compresspoint(ret[0],ret[1]);
}
