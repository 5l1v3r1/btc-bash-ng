#!/usr/bin/bc

# functions for points on elliptic curves

define void gety_api(x, a, b, p, *ret[]){

    auto q, z, ysq, tmp;

    q = (p - 1) / 2;
    z = invmod(2, q);
    ysq = mod((powmod(x, 3, p) + (a * x) + b), p);

    tmp = powmod(ysq, z, p);
    if (tmp % 2 == 0){

        ret[0] = tmp;
        ret[1] = mod(-tmp, p);
    } else {
        ret[0] = mod(-tmp, p);
        ret[1] = tmp;
    }
}

define void gety(x){

    auto ret[];

    gety_api(x, curve_a, curve_b, curve_p, ret[]);

    print "\n# gety\n# Y1 : ", ret[0], "\n# Y2 : ", ret[1], "\n";
}

define ispoint_api(x, y, a, b, p){

    auto ysq, xcb, ax, ans;

    ysq = powmod(y, 2, p);
    xcb = powmod(x, 3, p);
    ax = mod(a * x, p);

    ans = mod( mod((ysq - xcb - ax - b), p), p);
    return (ans == 0);
}

define ispoint(x, y){

    return ispoint_api(x, y, curve_a, curve_b, curve_p);
}

define compresspoint_api(x, y){

    if ( ispoint(x, y) ){

        if (y % 2 == 1){

            return (x + 3*(10 ^ curve_words));
        } else {

            return (x + 2*(10 ^ curve_words));
        }
    } else {
        return 0;
    }
}

define void compresspoint(x, y){

    auto res;

    res = compresspoint_api(x, y);
    print "0", res, "\n";
}

define void uncompresspoint_api(x, *ret[]){

    auto yarr[];

    gety_api(( mod(x, 10 ^ curve_words) ), curve_a, curve_b, curve_p, yarr[]);

    if ( x > ( 3*(10 ^ curve_words) ) ){

        ret[0] = ( x - 3*(10 ^ curve_words) );
        ret[1] = yarr[1];
    } else if ( x > ( 2*(10 ^ curve_words) ) ){

        ret[0] = ( x - 2*(10 ^ curve_words) );
        ret[1] = yarr[0];
    } else {

        ret[0] = 0;
        ret[1] = 0;
    }
}

define void uncompresspoint(x){

    auto ret[];

    uncompresspoint_api(x, ret[]);
    left_pad(ret[0], curve_words);
    left_pad(ret[1], curve_words);
}
