#!/usr/bin/bc

# functions for simple modular arithmetic

# simple mod
define mod(a, n){

    if (a < 0){

        if (-a == n ){
            return 0;
        }

        return ((a % n) + n);
    }

    return (a % n);
}

# returns the inverse of a in n
# (stripped down egcd)
# https://en.wikipedia.org/wiki/Modular_multiplicative_inverse#Extended_Euclidean_algorithm
define invmod(a, n){

    auto low_med, high_med, low, high, r, new_r, new_med;

    if (a == 0){
        return 0;
    }

    low_med = 1;
    low = mod(a, n);
    high = n;

    while (low > 1){

        r = ( high / low);
        new_r = (high - (low * r));
        new_med = (high_med - (low_med * r));
        high = low;
        high_med = low_med;
        low = new_r;
        low_med = new_med;
    }

    return mod(low_med, n);
}

# returns base to the power exp mod n
define powmod(base, exp, n){

    auto res, b, e;
    b = base;
    e = exp;

    res = 1;
    b = mod(b, n);
    while ( e > 1 ){

        if (e % 2 == 1){

            res = mod((res * b), n);
        }

        e = (e / 2);
        b = mod((b * b), n);
    }

    if ( e == 1 ){

        res = mod((res * b), n);
    }

    return res;
}
